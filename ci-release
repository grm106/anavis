#!/usr/bin/env node

require('shelljs/global');

const fs = require('fs');
const path = require('path');
const gh = require('ghreleases');
const semver = require('semver');
const Dropbox = require('dropbox');
const pkg = require('./package.json');
const markdownEscape = require('markdown-escape');
const commitsBetween = require('commits-between');

const DROPBOX_TOKEN = process.env.DROPBOX_TOKEN;
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USER = process.env.GITHUB_USER;

// CI=true
// TRAVIS=true
// USER=travis (do not depend on this value)
// HOME=/Users/travis (do not depend on this value)
// Additionally, Travis CI sets environment variables you can use in your build, e.g. to tag the build, or to run post-build deployments.

// TRAVIS_BRANCH:For builds not triggered by a pull request this is the name of the branch currently being built; whereas for builds triggered by a pull request this is the name of the branch targeted by the pull request (in many cases this will be master).
// TRAVIS_BUILD_DIR: The absolute path to the directory where the repository being built has been copied on the worker.
// TRAVIS_BUILD_ID: The id of the current build that Travis CI uses internally.
// TRAVIS_BUILD_NUMBER: The number of the current build (for example, “4”).
// TRAVIS_COMMIT: The commit that the current build is testing.
// TRAVIS_COMMIT_RANGE: The range of commits that were included in the push or pull request. (Note that this is empty for builds triggered by the initial commit of a new branch.)
// TRAVIS_JOB_ID: The id of the current job that Travis CI uses internally.
// TRAVIS_JOB_NUMBER: The number of the current job (for example, “4.1”).
// TRAVIS_PULL_REQUEST: The pull request number if the current job is a pull request, “false” if it’s not a pull request.
// TRAVIS_SECURE_ENV_VARS: Whether or not secure environment vars are being used. This value is either “true” or “false”.
// TRAVIS_REPO_SLUG: The slug (in form: owner_name/repo_name) of the repository currently being built. (for example, “travis-ci/travis-build”).
// TRAVIS_OS_NAME: On multi-OS builds, this value indicates the platform the job is running on. Values are linux and osx currently, to be extended in the future.
// TRAVIS_TAG: If the current build is for a git tag, this variable is set to the tag’s name.

const isPullRequest = process.env.TRAVIS_PULL_REQUEST !== 'false';
const commitish = process.env.TRAVIS_COMMIT || null;
const tagName = process.env.TRAVIS_TAG || null;
const branchName = process.env.TRAVIS_BRANCH;
const isOsx = process.env.TRAVIS_OS_NAME === 'osx';
const buildVersion = semver.valid(tagName);
const mainVersion = [semver.major(buildVersion), semver.minor(buildVersion), semver.patch(buildVersion)].join('.');
const prerelease = semver.prerelease(buildVersion) || [];

if (branchName !== 'master' || !buildVersion) {
  console.log('Branch is not master or there is no version tag, will exit the script.');
  process.exit(0);
}

if (mainVersion !== pkg.version) {
  console.error(`Tag version ${buildVersion} does not correspond to package version ${pkg.version}.`);
  process.exit(-1);
}

if (prerelease && prerelease[0] !== 'beta') {
  console.error(`Tag version ${buildVersion} does not fulfill version name constraints.`);
  process.exit(-1);
}

const buildConfigName = prerelease[0] || 'stable';
const buildConfigFile = `./build/config.${buildConfigName}.json`;
const buildConfig = require(buildConfigFile);

const artifactNames = {
  linux: `${pkg.name}-${buildVersion}-linux-x86_64.AppImage`,
  win: `${pkg.name}-${buildVersion}-windows.exe`,
  osx: `${pkg.name}-${buildVersion}-osx.dmg`
};

const filesToDownload = [artifactNames.osx, artifactNames.win, artifactNames.linux];
const fileToUpload = filesToDownload.map(file => path.resolve(`./release/${file}`));
const releaseName = `${buildConfig.productName} v${buildVersion}`;
const githubAuth = { token: GITHUB_TOKEN, user: GITHUB_USER };

async function release() {
  await downloadArtifacts(filesToDownload, './release');
  const latestRelease = await getLatestGithubRelease(githubAuth, 'learningmedia', 'anavis');
  const commits = await commitsBetween({ from: latestRelease.tag_name });
  const releaseNotes = await createReleaseNotes(commits);
  const release = await createGithubRelease(githubAuth,'learningmedia', 'anavis', { tag_name: tagName, name: releaseName, body: releaseNotes });
  await uploadAssetsToGithubRelease(githubAuth, 'learningmedia', 'anavis', release.id, fileToUpload);
}

release().catch(error => {
  console.error(error);
  process.exit(-1);
});

/// DROPBOX HELPERS //////////////////////////////////////////////////////////////////////////////

function downloadArtifacts(dropboxFiles, targetDir) {
  const downloadDir = path.resolve(targetDir);
  mkdir('-p', downloadDir);
  return Promise.all(dropboxFiles.map(file => downloadFromDropbox(`/${file}`, path.join(downloadDir, file))));
}

function downloadFromDropbox(source, target) {
  const dbx = new Dropbox({ accessToken: DROPBOX_TOKEN });
  return dbx.filesDownload({ path: source })
    .then(data => fs.writeFileSync(target, data.fileBinary, 'binary'));
}

function getLatestGithubRelease(githubAuth, owner, repo) {
  return new Promise((reject, resolve) => {
    gh.getLatest(githubAuth, owner, repo, (err, res) => {
      if (err) {
        reject(err);
      } else {
        resolve(res);
      }
    });
  });
}

function createGithubRelease(githubAuth, owner, repo, data) {
  return new Promise((reject, resolve) => {
    gh.create(githubAuth, owner, repo, data, (err, res) => {
      if (err) {
        reject(err);
      } else {
        resolve(res);
      }
    });
  });
}

function uploadAssetsToGithubRelease(githubAuth, owner, repo, releaseId, files) {
  return new Promise((reject, resolve) => {
    gh.uploadAssets(githubAuth, owner, repo, releaseId, files, (err, res) => {
      if (err) {
        reject(err);
      } else {
        resolve(res);
      }
    });
  });
}

function createReleaseNotes(commits) {
  return commits.map(c => `* ${markdownEscape(c.subject)}`).join('\n');
}
